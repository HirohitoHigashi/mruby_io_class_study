# UART

## 方針、リクエストなど

* 基本的な機能のメソッド名や仕様は、Rubygem の ruby-serialport https://rubygems.org/gems/serialport/ に似せる => 取りやめ
* タイムアウトをサポートするかユーザプログラムに委ねるかが問われるが、ライブラリ作成者の負担が大きくなりすぎる懸念があるので、一旦はサポートせずユーザプログラムに任せる方針とし、それを妨げないAPI設計にする。
* 通信途中でパラメータ（ボーレート等）を変更するケースがあるので、設定変更用メソッドがあった方が良い。
* 読み込んだ結果に対して、each_byte とか each_line が使いたい。（羽角） => Cレイヤでは難しい。mrblibのようにRubyで記述し追加はできる。
* break 信号の処理もできるようにしたい。（田中）
* シリアルが2つ以上使える場合のサポートをしたい。（三牧）
* 出力が終わったかの確認メソッドが欲しい。（三牧）
* 入力できるバイト数の事前確認をするメソッドが欲しい（三牧）

--------------------------------------------------------------------------------
# コンストラクタ
```
UART.new( id, *params )
```

* パラメータデフォルト値は、可能であれば以下の設定に従う。
  * ボーレート 9600
  * データ8ビット
  * ストップビット1ビット
  * パリティー無し
  * フロー制御無し
* 使用するピンを変更できる場合がある。

### 例
```
# UART1を、全てデフォルトパラメータで使う。
uart1 = UART.new( 1 )

# UART2を、指定のパラメータで使う。
uart2 = UART.new( 2, baud:19200, data_bits:8, stop_bits:1, parity:UART::NONE, flow_control:UART::RTSCTS )

# システムデフォルトのピン配置を変更して使う。
uart3 = UART.new( 3, txd_pin:15, rxd_pin:16 )
```

### パラメータ用定数
```
UART::NONE
UART::EVEN
UART::ODD
UART::RTSCTS
```

--------------------------------------------------------------------------------
# インスタンスメソッド
## 設定
```
setmode( *params )
```

* UARTのモード（パラメータ）を任意のタイミングで変更する。

TODO: メソッド名　要再検討  GPIOと同じにしてあるが、、、  
gemとの互換性を考え、同様の機能で set_modem_params() を用意していたが、筋が悪そう。  
ピン配置変更の事も考えると、setmode でもなさそう。  
MicroPython 由来とし、init() にするか？
> setmode() のメソッド名に決定する。

### 例
```
uart3.setmode( bard:38400 )
```

----------------------------------------
## 指定されたバイト数のデータを読み込む
```
read( n_bytes ) -> String
```

* 指定されたバイト数のデータを読み込む。
* 指定されたバイト数のデータが到着していない場合、ヌルストリングを返す。
* 引数が指定されなければ、リードバッファに到着している全データを返す。データがなければヌルストリングを返す。

TODO: nil を返す仕様で正解か？ ヌルストリングではダメか？  
`read( 10 ).each_byte {...}` とか、したくないか？  
文字化けなどで10バイト送られなくなるケースが容易に想像できるので、意図的に使えなくしておくか？  
> => ヌルストリングに統一する。

TODO: n_bytes を指定しない場合も許すか？　その場合の動作は？
> => RubyのI/Oクラスとコンパチブル動作とする。

### 例
```
val = uart1.read(10)
```

----------------------------------------
## リードバッファに到着している分のデータを返す
```
read_nonblock( n_bytes ) -> String
```

* リードバッファに到着しているデータを、引数で指定した n_bytes を最大値として返す。
* リードバッファが空ならば、ヌルストリングを返す。

MEMO:
* 通信相手が送ってくるバイト数が分からない場合に有用だったのでサポートした。
* Rubyのread_nonblockは、リードできるデータが無い時は例外を発生する。そこまで真似せずに、read()と仕様を合わせておく方がよさそうに思う。

### 例
```
val = uart1.read_nonblock( 1024 ) 
```

----------------------------------------
## リード可能バイト数の取得
```
bytes_available()
```

* リードバッファに到着している読み込み可能バイト数を返す。
  
### 例
```
uart1.bytes_available()
```

----------------------------------------
## 文字列を1行読み込む
```
gets() -> String
```

* 文字列を一行読み込む。内部的にはリードバッファ内の "\n" までのバイト列を返す。
* リードバッファに "\n" が無い場合、ヌルストリングを返す。

TODO: 改行コードが、"\n" 固定だが、問題ないだろうと思う。  
TODO: これもリードバッファに望む結果が無い場合は、CRubyと仕様が違う。CRubyはブロックする。　　
TODO: readline() もあっても良いか？　メモリの無駄か？ => 無し  

### 例
```
val = uart1.gets()
```


----------------------------------------
## 出力
```
write( string )
```

* データを送信する。
* 利用する低レイヤーライブラリやハードウェアFIFOなどにより、データの送信完了を待たずに戻る場合があります。

### 例
```
uart1.write("Output string\r\n")
```

TODO: puts() も必要か？ => putsは、原案では実装しない。必要なら自分でオーバライド。
TODO: ハードウェアフロー制御により送信ができない場合にどうするか？ => ブロックする。

----------------------------------------
## 受信バッファクリア
```
clear_rx_buffer()
```

* 受信バッファをクリアします。
  
### 例
```
uart1.clear_rx_buffer()
```


----------------------------------------
## 送信バッファクリア
```
clear_tx_buffer()
```

* 送信バッファをクリアします。

### 例
```
uart1.clear_tx_buffer()
```

----------------------------------------
## 送信完了を待つ
```
flush()
```

* 送信バッファに溜まったデータの送信完了まで停止します。
  
### 例
```
uart1.flush()
```

----------------------------------------
## break信号の送信
```
break( time )
```

* break信号を送信します。
* timeはオプションで、秒で指定します。
* ハードウェアによっては、timeは一律（e.g. 12bit）で、変更できません。
  
### 例
```
uart1.break( 0.1 )
```
