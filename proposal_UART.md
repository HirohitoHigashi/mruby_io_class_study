# UART

## 方針、リクエストなど

* 基本的な機能のメソッド名や仕様は、Rubygem の ruby-serialport https://rubygems.org/gems/serialport/ に似せる。
* タイムアウトをサポートするかユーザプログラムに委ねるかが問われるが、ライブラリ作成者の負担が大きくなりすぎる懸念があるので、一旦はサポートせずユーザプログラムに任せる方針とし、それを妨げないAPI設計にする。
* 通信途中でパラメータ（ボーレート等）を変更するケースがあるので、設定変更用メソッドがあった方が良い。
* 読み込んだ結果に対して、each_byte とか each_line が使いたい。（羽角） => Cレイヤでは難しい。mrblibのようにRubyで記述し追加はできる。
* break 信号の処理もできるようにしたい。（田中）
* シリアルが2つ以上使える場合のサポートをしたい。（三牧）
* 出力が終わったかの確認メソッドが欲しい。（三牧）

--------------------------------------------------------------------------------
# コンストラクタ
```
UART.new( id, params... )
```

* パラメータデフォルト値は、可能であれば以下の設定に従う。
  * ボーレート 9600
  * データ8ビット
  * ストップビット1ビット
  * パリティー無し
  * フロー制御無し
* TODO: 使用するピンを変更できる場合がある。サポートしたい。

### 例
```
# UART1を、全てデフォルトパラメータで使う。
uart1 = UART.new( 1 )

# UART2を、指定のパラメータで使う。
uart2 = UART.new( 2, baud:19200, data_bits:8, stop_bits:1, parity:UART::NONE, flow_control:UART::RTSCTS )

# システムデフォルトのピン配置を変更して使う。
uart3 = UART.new( 3, txd_pin:15, rxd_pin:16 )
```

### パラメータ用定数
```
UART::NONE
UART::EVEN
UART::ODD
UART::RTSCTS
```

--------------------------------------------------------------------------------
# インスタンスメソッド
## 設定
```
setmode( params... )
```

* UARTのモード（パラメータ）を任意のタイミングで変更する。

TODO: メソッド名　要再検討  GPIOと同じにしてあるが、、、  
gemとの互換性を考え、同様の機能で set_modem_params() を用意していたが、筋が悪そう。  
ピン配置変更の事も考えると、setmode でもなさそう。  
MicroPython 由来とし、init() にするか？

### 例
```
uart3.setmode( bard:38400, txd_pin:22, rxd_pin:23 )
```

----------------------------------------
## 指定されたバイト数のデータを読み込む
```
read( n_bytes ) -> String, Nil
```

* 指定されたバイト数のデータを読み込む。
* 指定されたバイト数のデータが到着していない場合、nilを返す。

TODO: nil を返す仕様で正解か？ ヌルストリングではダメか？  
`read( 10 ).each_byte {...}` とか、したくないか？  
文字化けなどで10バイト送られなくなるケースが容易に想像できるので、意図的に使えなくしておくか？  

TODO: n_bytes を指定しない場合も許すか？　その場合の動作は？

(案)

* 引数で指定されたバイト数のデータを読み込む。
* 指定されたバイト数のデータが到着していない場合、nilを返す。
* 引数が指定されなければ、リードバッファに到着している全データを返す。データがなければヌルストリングを返す。


### 例
```
val = uart1.read(10)
```

----------------------------------------
## リードバッファに到着している分のデータを返す
```
read_nonblock( n_bytes ) -> String, Nil
```

* リードバッファに到着しているデータを、引数で指定した n_bytes を最大値として返す。
* リードバッファが空ならば、nilを返す。
* 通信相手が送ってくるバイト数が分からない場合に有用だったのでサポートした。

TODO: Rubyのread_nonblockは、リードできるデータが無い時は例外を発生する。そこまで真似せずに、read()と仕様を合わせておく方がよさそうに思う。

### 例
```
val = uart1.read_nonblock( 1024 ) 
```

----------------------------------------
## 文字列を1行読み込む
```
gets() -> String, Nil
```

* 文字列を一行読み込みます。内部的にはリードバッファ内の "\n" までのバイト列を返す。
* リードバッファに "\n" が無い場合、nilを返す。

TODO: 改行コードが、"\n" 固定だが、問題ないだろうと思う。  
TODO: これもリードバッファに臨む結果が無い場合は、CRubyと仕様が違う。CRubyはブロックする。　　
TODO: readline() もあっても良いか？　メモリの無駄か？
  
### 例
```
val = uart1.gets()
```



----------------------------------------
## 出力
```
write( string )
```

* データを送信します。
* 利用する低レイヤーライブラリやハードウェアFIFOなどにより、データの送信完了を待たずに戻る場合があります。

### 例
```
uart1.write("Output string\r\n")
```

TODO: puts() も必要か？
TODO: ハードウェアフロー制御により送信ができない場合にどうするか？

----------------------------------------
## 受信バッファクリア
```
clear_rx_buffer()
```

* 受信バッファをクリアします。
  
### 例
```
uart1.clear_rx_buffer()
```


----------------------------------------
## 送信バッファクリア
```
clear_tx_buffer()
```

* 送信バッファをクリアします。

### 例
```
uart1.clear_tx_buffer()
```

----------------------------------------
## 送信完了を待つ
```
flush()
```

* 送信バッファに溜まったデータの送信完了まで停止します。
  
### 例
```
uart1.flush()
```

----------------------------------------
## break信号の送信
```
break( time )
```

* break信号を送信します。
* timeはオプションで、秒で指定します。
* ハードウェアによっては、timeは一律（e.g. 12bit）で、変更できません。
  
### 例
```
uart1.break( 0.1 )
```
